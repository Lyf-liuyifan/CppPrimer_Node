# C++ Primer 阅读补充

​	笔记主要是关于使用C++途中所需要注意的细节，以及对C++Primer的补充

## 2.变量和基本类型

### 2.2变量

#### 2.2.1变量定义

​	变量的定义初始化不能进行隐式转换

#### 2.2.2变量声明和定义的关系

​	如果想声明一个变量而不是声明一个变量，可以使用extern关键字来声明

```cpp
extern int i;//声明
extern int i = 100;//初始化抵消了，这是定义
```

#### 2.2.4名字的作用域

​	当内层作用域与外层作用域名字重名，那么外层的名字会被隐藏，这时候要访问外层的名字得加作用域，比如访问全局的得加==：：==。

​	还有就是有个需要注意的点就是for，if等函数就算没有写大括号，后面一条语句也是在其作用域内的。

### 2.3复合类型

#### 2.3.1引用

​	引用赋值引用就等于变量赋值给引用，没什么区别，就是普通传递值。

​	引用不能用字面值去初始化，只能是对应类型的变量，只有初始化之后才能进行隐式类型转换。

#### 2.3.3理解复合型声明

​	只有int类型没有int*或者int&类型所以

```cpp
int* i, j;//i为指针类型，j为int型
const int i = 2, j = 3;//const是跟类型的，这说明j也是一个不可修改的变量
```

#### 2.4.2指针和const

​	指针和引用的const的意思只是不能通过指针和引用去修改值而不是说地址上的值不能改变。

#### 2.4.3顶层const

​	**1.顶层const:对象本身不可以改变：**

- 定义：const直接修饰变量本身，表示改变量的值无法被修改

  ```cpp
  const int i = 0;//i是顶层const
  ```

- 特点：

  无论变量是什么基本类型，还是指针，只要修饰本身就是顶层const。

**2.底层const：指针/引用指向的对象不可变**（只有指针或引用才有这特性

​	拷入拷出的对象必须拥有相同的底层资格。或者另个对象的数据类型可以相互转换。一般来说，==非常量可以转换成常量==。顶层const的拷贝是不受影响的。值得注意的是：一般是看被拷贝是否是底层const。

```cpp
const int ci = 42;
int i = 0;
i = ci//拷贝ci，因为ci是顶层const所以和普通变量没区别
const int* p2 = &ci;//p2 是底层const
const int* const p3 = p2;
p2 = p3;//底层类型相同，顶层不受影响
int* p = p3;//p3有底层const 所以这条语句是错误的
p2 = p3;//right
p2 = &i;//正确 int* 可以转换成const int*
int& r = ci;//ci有底层所以不行
const int& r2 = i;//可以因为非常量可以转换成非常量
```



## 8.IO库

### 8.1关于Cin

#### 8.1.1Cin怎么读取输入的

​	我们如果不知道cin到底怎么读取输入的话，会造成很多意外的情况和bug，比如当Cin要把输入读取到char类型当中的时候，他并不会忽略开头的换行符，假如我们前一次输入了回车，下一次读取输入就会把换行读进去，这并不是我们想看到的。

​	其他的读入都是会忽略空白符（空格， 换行符， 制表符

- Windows允许通过键盘模拟文件尾：Ctrl+Z

#### 8.1.2Cin作为判断条件

​	不仅Cin可以在while中做为循环的判断条件，在for循环中也可以，只要是bool类型的都可以，要学会灵活运用这点，可以做出更优美的代码。

```c++
for(Sales_item item;std::cin >> item; std::cout << item);
```

